<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>Instalación</h1>

		<p>
			Puedes instalar three.js con [link:https://www.npmjs.com/ npm] y building tools, o empezar rápidamente con un alojamiento estático o un CDN. Para la mayoría de usuarios, instalar desde npm es la mejor alternativa.
		</p>

		<p>
			Indepentientemente de lo que elijas, sé consistente e importa todos los archivos desde la misma versión de la biblioteca. Mezclar archivos de diferentes fuentes puede hacer que se añada código duplicado, o incluso que se rompa la aplicación de forma inesperada.
		</p>

		<p>
			Todos los métodos de instalación de three.js dependen de ES modules (ver [link:https://eloquentjavascript.net/10_modules.html#h_hF2FmOVxw7 Eloquent JavaScript: ECMAScript Modules]), que permiten añadir solo las partes de la biblioteca necesarias para el proyecto final.
		</p>

		<h2>Instalación desde npm</h2>

		<p>
			Para instalar el módulo de npm [link:https://www.npmjs.com/package/three three], abre una ventana de terminal en la carpeta de tu proyecto y ejecuta:
		</p>

		<code>
		npm install --save three
		</code>

		<p>
			El paquete se descargará e instalará. Una vez hecho esto, ya podrás importarlo en tu código:
		</p>

		<code>
		// Option 1: Import the entire three.js core library.
		import * as THREE from 'three';

		const scene = new THREE.Scene();


		// Option 2: Import just the parts you need.
		import { Scene } from 'three';

		const scene = new Scene();
		</code>

		<p>
			Cuando se instala desde npm, casi siempre se utiliza algún tipo de [link:https://eloquentjavascript.net/10_modules.html#h_zWTXAU93DC bundling tool] para agrupar todos los paquetes que requiere el proyecto en un único archivo JavaScript. Aunque se puede utilizar cualquier bundler de JavaScript moderno con three.js, la opción más popular es [link:https://webpack.js.org/ webpack].
		</p>

		<p>
			No todas las funcionalidades son accesibles directamente a través del módulo <em>three</em> (también llamado "bare import"). Otros elementos importantes de la biblioteca — como los controles, loaders y efectos de posprocesamiento - deben importarse desde la subcarpeta [link:https://github.com/mrdoob/three.js/tree/dev/examples/jsm examples/jsm]. Para saber más, consulta los <em>Ejemplos</em> más abajo.
		</p>

		<p>
			Aprende más sobre los módulos de npm en [link:https://eloquentjavascript.net/20_node.html#h_J6hW/SmL/a Eloquent JavaScript: Instalando con npm].
		</p>

		<h2>Instalación desde CDN o alojamiento estático</h2>

		<p>
			La biblioteca three.js puede utilizarse sin ningún sistema de compilación, ya sea subiendo los archivos a tu propio servidor web o utilizando un CDN existente. Como la biblioteca depende de ES modules, cualquier script que haga referencia a ella debe utilizar <em>type="module"</em> como se muestra a continuación:
		</p>

		<code>
		&lt;script type="module">

		  // Find the latest version by visiting https://unpkg.com/three.

		  import * as THREE from 'https://unpkg.com/three@&lt;version&gt;/build/three.module.js';

		  const scene = new THREE.Scene();

		&lt;/script>
		</code>

		<p>
			No todas las funcionalidades son accesibles a través del módulo <em>build/three.module.js</em>. Otros elementos importantes de la biblioteca — como los controles, loaders y efectos de posprocesamiento - deben importarse desde la subcarpeta [link:https://github.com/mrdoob/three.js/tree/dev/examples/jsm examples/jsm]. Para saber más, consulta los <em>Ejemplos</em> más abajo.
		</p>


		<h2>Ejemplos</h2>

		<p>
			El core de three.js se centra en los componentes más importantes de un motor 3D. Muchos otros componentes útiles - como los controles, loaders y efectos de posprocesamiento - forman parte del directorio [link:https://github.com/mrdoob/three.js/tree/dev/examples/jsm examples/jsm]. Se denominan "ejemplos", porque si bien se pueden utilizar desde el principio, también están pensados para ser modificados y personalizados. Estos componentes se mantienen siempre sincronizados con la biblioteca core, mientras que los paquetes de terceros similares  en npm son mantenidos por diferentes personas y pueden no estar actualizados.
		</p>

		<p>
			Los ejemplos no necesitan ser <em>instalados</em> por separado, pero sí necesitan ser <em>importados</em> por separado. Si se ha instalado three.js con npm, se puede cargar el componente [page:OrbitControls] con:
		</p>


		<code>
		import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

		const controls = new OrbitControls();
		</code>

		<p>
			Si se ha instalado three.js desde un CDN, utiliza el mismo CDN para instalar otros componentes:
		</p>

		<code>
		&lt;script type="module">

		  // Find the latest version by visiting https://unpkg.com/three.

		  import { OrbitControls } from 'https://unpkg.com/three@&lt;version&gt;/examples/jsm/controls/OrbitControls.js';

		  const controls = new OrbitControls();

		&lt;/script>
		</code>

		<p>
			Es importante que todos los archivos utilicen la misma versión. No importes diferentes ejemplos de diferentes versiones, ni utilices ejemplos de una versión diferente a la de la propia librería three.js.
		</p>

		<h2>Compatibilidad</h2>

		<h3>Importaciones de CommonJS</h3>

		<p>
			Mientras que los bundlers modernos de JavaScript soportan ES modules por defecto, algunas build tools más antiguas pueden no hacerlo. En esos casos es probable que puedas configurar el bundler para que soporte ES modules: [link:http://browserify.org/ Browserify] solo necesita el plugin [link:https://github.com/babel/babelify babelify], por ejemplo.
		</p>

		<h3>Importar maps</h3>

		<p>
			Las rutas importadas difieren cuando se instala desde npm, en comparación con la instalación desde un alojamiento estático o un CDN. Somos conscientes de que esto es un problema ergonómino para ambos grupos de usuarios. Las personas desarrolladoras que utilizan build tools y bundlers prefieren las especificaciones de paquetes básicos, (p. ej. 'three') en lugar de las rutas relativas, y los archivos en la carpeta <em>examples/</em> utilizan referencias relativas a <em>three.module.js</em> que no siguen esta expectativa. Quienes no utilicen build tools - para prototipado rápido, por aprendizaje o por preferencia personal - puede que tampoco les gusten esas importaciones relativas, que requieren ciertas estructuras de carpetas y son menos flexibles que el namespace <em>THREE.*</em>.
		</p>

		<p>
			Esperamos eliminar estas rulas relativas cuando [link:https://github.com/WICG/import-maps import maps] esté ampliamente disponible, sustituyéndolas por especificadores de paquetes bare especificados con el nombre del paquete npm, 'three'. Esto se ajusta más a las expectativas de las build tools para paquetes npm, y permite a ambos grupos de usuarios escribir exactamente el mismo código al importar un archivo. Para los usuarios que prefieren evitar las build tools, un simple mapeo JSON puede direccionar todas las importaciones a un CDN o una carpeta de archivos estáticos. De forma experimental, puedes probar a utilizar importaciones simplificadas hoy en día con el polyfill de import map, como se muestra en nuestro [link:https://glitch.com/edit/#!/three-import-map?path=index.html ejemplo de import map].
		</p>

		<h3>Node.js</h3>

		<p>
			El uso de three.js en [link:https://eloquentjavascript.net/20_node.html Node.js] puede ser complicado, por dos razones:
		</p>

		<p>
			En primer lugar, dado que three.js está construido para la web, depende del navegador y las APIs del DOM que no siempre existen en Node.js. Algunos de estos problemas pueden resolverse usando correctores de compatibilidad como [link:https://github.com/stackgl/headless-gl headless-gl], o sustituyendo componentes como [page:TextureLoader] por alternativas personalizadas. Otras APIs del DOM pueden estar profundamente entrelazadas con el código que las utiliza, y será más complicado de solucionar. Agredecemos las pull requests sencillas y mantenibles para mejorar el soporte de Node.js, pero recomendamos abrir una issue para discutir las mejoras primero.
		</p>

		<p>
			Segundo, el soporte de Node.js para ES modules es... complicado. A partir de Node.js v12, la biblioteca core puede ser importada como un módulo CommonJS, mediante <em>require('three')</em>. Sin embargo, la mayoría de los componentes de ejemplo en <em>examples/jsm</em> no pueden. Es posible que las futuras versiones de Node.js resuelvan esto, pero mientras tanto es probable que tengas que utilizar métodos alternativos como [link:https://github.com/standard-things/esm esm] para que tu aplicación de Node.js reconozca los ES modules.
		</p>

	</body>
</html>
